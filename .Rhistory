?BH
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
#' Discrete survival, straying, and recruitment projection.
#' @param stray_mat a square L x L stray matrix.
#' @param mort_mat an S x L mortality matrix OR a vector of length L OR a single value.
#' @param fec_at_age a vector or matrix of fecundity at age including only mature stages.
#' @param eggs a vector of eggs associated with the next years cohort (fed into the stock recruit relationship).
#' @param E0 egg production at B0.
#' @param h steepness.
#' @param R0 recruitment at B0.
#' @param stage_maturity stage class at maturity.
#' @param errors a vector of length L or single value of recruitment deviations.
#' @param X an S x L matrix of initial abundances of each stage (S) at each location (L).
#' @param n_stages number of stage classes.
#' @param n_loc number of locations.
#' @example /inst/examples/survexample.R
#' @description Generates a single projection including survival followed by straying and reproduction using a matrix algebra in discrete time.
#' @seealso surv_stray_recr_ode
SSR_linear <- function(stray_mat, mort_mat, fec_at_age,
eggs, E0, h , R0,
alpha=NULL,beta=NULL,
stage_maturity, errors = 0, X0, n_stages, n_loc) {
### create empty array
X1 <- array(as.numeric(NA), dim = c(n_stages, n_loc))
if (length(dim(mort_mat)) > 2) {
### fill in mortality at age
for (j in 1:5) {
X1[(stage_maturity - 1):n_stages, j] <- mort_mat[, , j] %*% X0[, j]
}
} else {
X1[(stage_maturity - 1):n_stages, ] <- mort_mat %*% X0
}
X1[(stage_maturity - 1):n_stages, ] <- X1[2:n_stages, ] %*% t(stray_mat)
X1[1, ] <- fec_at_age %*% X1[stage_maturity:n_stages, ]
# add recruitment
if (is.null(alpha)){
X1[2, ] <- mapply(BH, E = eggs, E0 = E0, h = h, R0 = R0) * exp(errors)
}
else {
X1[2, ] <- mapply(BH, E = eggs, alpha= alpha,beta=beta) * exp(errors)
}
return(X1)
}
#' Continuous time survival, straying, and harvest with discrete recruitment
#' @param stray a square L x L stray matrix.
#' @param Z an S x L instantaneous mortality matrix OR a vector of length L OR a single value.
#' @param fec_at_age a vector or matrix of fecundity at age including only mature stages.
#' @param eggs a vector of eggs associated with the next years cohort (fed into the stock recruit relationship).
#' @param E0 egg production at B0.
#' @param h steepness.
#' @param R0 recruitment at B0.
#' @param stage_maturity stage class at maturity.
#' @param errors a vector of length L or single value of recruitment deviations.
#' @param n_stages number of stage classes.
#' @param n_loc number of locations.
#' @param inst_h a matrix vector or single value with instantaneous fishing mortality
#' @param X0 an S x L matrix of initial abundances of each stage (S) at each location (L).
#' @param method the method of numerical integration (defaults to "lsoda").
#' @example /inst/examples/survexample_ode.R
#'@description Generates a single projection including simultaneous survival, straying and harvest using a system of ordinary differential equations followed by discrete reproduction
SSR_linear_ode <- function(stray, Z, fec_at_age, eggs,
E0, h, R0,
alpha= NULL,beta= NULL,
stage_maturity, errors = 0,
n_loc , n_stages,
inst_h = 0, X0, method = "lsoda") {
S <- n_stages - 1
L <- n_loc
X1 <- array(as.numeric(NA), dim = c(n_stages, n_loc))
col <- rep(1:(S * L), L)
row <- rep(c(1:S), L * L) + rep(0:(L - 1), each = S * L) * S
Zmat <- diag(as.vector(-Z))
Smat <- matrix(simple_triplet_matrix(row, col, rep(t(stray), each = S)), ncol = 45)
diag(Smat) <- rep(diag(stray), each = S) - 1
Fmat <- diag(as.vector(inst_h), ncol = (L * S), nrow = (L * S))
A <- rbind(cbind(Zmat + Smat, matrix(0, nrow = 45, ncol = 45)),
cbind(Fmat, matrix(0, nrow = 45, ncol = 45)))
inits <- matrix(X0)
### generate the survivors and harvest totals ###
fin <- array(t(ode(y = c(X0, rep(0, (S * L))), times = c(0, 1),
func = linear_odes, parms = A, method = method)[2, -1]),
dim = c(S, L, 2))
### split survivors and harvests ###
harvest <- fin[, , 2]
survivors <- fin[, , 1]
survivors[S-1, ] <- survivors[S-1, ] + survivors[S, ]
X1[3:10,] <- survivors[1:8, ]
X1[1, ] <- fec_at_age %*% X1[stage_maturity:n_stages, ]
if (is.null(alpha)){
X1[2, ] <- mapply(BH, E = eggs, E0 = E0, h = h, R0 = R0) * exp(errors)
}
else {
X1[2, ] <- mapply(BH, E = eggs, alpha= alpha,beta=beta) * exp(errors)
}
return(list(X = X1, harvest = harvest))
}
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
library(Rmetapop)
example(SSR_linear_ode)
example(SSR_linear)
library(Rmetapop)
library(Rmetapop)
example(SSR_linear)
example(SSR_linear_ode)
?SSR_linear
library(Rmetapop)
?SSR_linear
?SSR_linear_ode
library(Rmetapop)
?SSR_linear_ode
?SSR_linear
?SSR_linear_ode
library(Rmetapop)
?SSR_linear_ode
library(Rmetapop)
?SSR_linear_ode
library(Rmetapop)
n_loc <- 5  # number of locations
n_iter <- 100  # number of years
n_stages <- 10  # number of stages including eggs and recruits
stage_mat <- 3  # stage # that indicates maturity
### 9 x L mortality matrix (can also be a single number or a single row with L
### columns)
mort <- matrix(0.334, ncol = n_loc, nrow = length((stage_mat - 1):(n_stages)))
mort_mat <- array(0, dim = c(n_stages - 1, n_stages - 1, n_loc))
### create identifier of matrix entries that correspond to mortality for quick
### replacement in the array
mort_mat_id <- array(matrix(1:n_stages^2, ncol = n_stages) %in% c(diag(matrix(1:n_stages^2,
ncol = n_stages)[-c(1), ]), n_stages^2), dim = c(n_stages, n_stages, n_loc))[-1,
-1, ]
### fecundity at age 3-10
fec_at_age <- fecundity_age(stage_mat:(n_stages))
### biomass at age 3-10 in tons
tons_at_age <- LVBweight(stage_mat:(n_stages))/1000
# matrix of mean stray probabilities, controled by a Cauchy distribution with scale = 0.3
spat_scale <- 0.3
stray_probs <- spat_cor_mat(n_loc, spat_scale = spat_scale, sumto1 = TRUE)
stray_probs # columns are probability of coming from, and row is probability going to (i.e. column 2 row 1 is going from location 2 to location 1)
colSums(stray_probs) # check to make sure it sums to 1
### stochastic realizations of the stray matrix for each year using the Dirichlet
### distribution with scale = 1000 (higher = less stochastic probabiliies)
C <- 1000
Crand <- ran_stray_prob(stray_mat=stray_probs,n_iter=n_iter,scale= C)
Crand[,,1:3]  #examine the first three stray matrices in the array
### BH stock-recruit parameters-must be either 1) a single value or 2) a vector of
### length L each
#h = 0.82
# B0 = 60000
# S0 = B0 * 1000/mean(LVBweight(9))  # convert B0 to mean number of fish
# E0 = S0 * fecundity_age(9)  ### eggs at 6 years old (scaled in millions)
# R0 = 5e+08  # in millions
# alpha <- (E0 * (1 - h))/(4 * h * R0)
# beta <- (5 * h - 1)/(4 * h * R0)
alpha <- 3227
beta <- 1/529032258
### spatiotemporal recruitment deviation parameters
phi = 0.5  ### first order autocorrelation
spat_sd = 2  ### gaussian spatial correlation paramete
site_sd = 0.2  ### overall log-scale recruitment standard deviation
### create matrices and vectors from parameters ### create spatiotemporal
### recruitment errors
errors <- spat_temp_ts(n_iter = n_iter, n_loc = n_loc, site_sd = site_sd, spat_sd = spat_sd,
phi = phi)
errors$cor_mat  ### correlation matrix among sites in log-scale recruitment error
errors$pacf  ### within site partial-autocorrelation function
error_mat <- errors$ts  ### save the ts for use in the simulation
### initial conditions ### create the data arrays
d1 <- c(0, 2:10)
d2 <- c(paste("Location", 1:n_loc, sep = "_"))
d3 <- 1:n_iter
## set up the abundance array
X <- array(as.numeric(NA), dim = c(10, n_loc, n_iter), dimnames = list(d1, d2, d3))
X[, , 1] <- matrix(c(rep(1e+08, 10), rep(0, each = 40)), ncol = n_loc, byrow = F)
X[, , 2] <- matrix(rep(1e+08, each = n_loc), ncol = n_loc, byrow = T)
## set up the adult biomass array
B <- array(NA, dim = c(n_loc, n_iter, 3), dimnames = list(d2, d3, c("Actual", "Observed",
"Forecast")))
B[, 1, ] <- tons_at_age %*% X[3:10, , 1]/1000
B[, 2, ] <- tons_at_age %*% X[3:10, , 2]/1000
## set up the Forecast adult biomass array
BF <- array(NA, dim = c(n_loc, n_iter, 3), dimnames = list(d2, d3, c("True", "Observed",
"Estimate")))
BF[, 1, ] <- tons_at_age %*% X[3:10, , 1]/1000
BF[, 2, ] <- tons_at_age %*% X[3:10, , 2]/1000
obs_sd <- 0.3
i=3
mort_mat[mort_mat_id] <- exp(-mort)
X[, , i] <- SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
X[,,3
]
X[, , 1] <- matrix(c(rep(1e+08, 10), rep(0, each = 40)), ncol = n_loc, byrow = F)
X[, , 2] <- matrix(c(rep(1e+08, 10), rep(0, each = 40)), ncol = n_loc, byrow = F)
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = 0,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
mort_mat[mort_mat_id] <- exp(-0)
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = 0,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
mort_mat[mort_mat_id] <- 0
mort_mat[mort_mat_id] <- 1
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = 0,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
mort_mat[mort_mat_id]
mort_mat
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = 0,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
### set up parameters for the simulation test survival & migration function with two
### locations ### general parameters ###
n_loc <- 5  # number of locations
n_iter <- 100  # number of years
n_stages <- 10  # number of stages including eggs and recruits
stage_mat <- 3  # stage # that indicates maturity
### 9 x L mortality matrix (can also be a single number or a single row with L
### columns)
mort <- matrix(0.334, ncol = n_loc, nrow = length((stage_mat - 1):(n_stages)))
mort_mat <- array(0, dim = c(n_stages - 1, n_stages - 1, n_loc))
### create identifier of matrix entries that correspond to mortality for quick
### replacement in the array
mort_mat_id <- array(matrix(1:n_stages^2, ncol = n_stages) %in% c(diag(matrix(1:n_stages^2,
ncol = n_stages)[-c(1), ]), n_stages^2), dim = c(n_stages, n_stages, n_loc))[-1,
-1, ]
### fecundity at age 3-10
fec_at_age <- fecundity_age(stage_mat:(n_stages))
### biomass at age 3-10 in tons
tons_at_age <- LVBweight(stage_mat:(n_stages))/1000
# matrix of mean stray probabilities, controled by a Cauchy distribution with scale = 0.3
spat_scale <- 0.3
stray_probs <- spat_cor_mat(n_loc, spat_scale = spat_scale, sumto1 = TRUE)
stray_probs # columns are probability of coming from, and row is probability going to (i.e. column 2 row 1 is going from location 2 to location 1)
colSums(stray_probs) # check to make sure it sums to 1
### stochastic realizations of the stray matrix for each year using the Dirichlet
### distribution with scale = 1000 (higher = less stochastic probabiliies)
C <- 1000
Crand <- ran_stray_prob(stray_mat=stray_probs,n_iter=n_iter,scale= C)
Crand[,,1:3]  #examine the first three stray matrices in the array
### BH stock-recruit parameters-must be either 1) a single value or 2) a vector of
### length L each
#h = 0.82
# B0 = 60000
# S0 = B0 * 1000/mean(LVBweight(9))  # convert B0 to mean number of fish
# E0 = S0 * fecundity_age(9)  ### eggs at 6 years old (scaled in millions)
# R0 = 5e+08  # in millions
# alpha <- (E0 * (1 - h))/(4 * h * R0)
# beta <- (5 * h - 1)/(4 * h * R0)
alpha <- 3227
beta <- 1/529032258
### spatiotemporal recruitment deviation parameters
phi = 0.5  ### first order autocorrelation
spat_sd = 2  ### gaussian spatial correlation paramete
site_sd = 0.2  ### overall log-scale recruitment standard deviation
### create matrices and vectors from parameters ### create spatiotemporal
### recruitment errors
errors <- spat_temp_ts(n_iter = n_iter, n_loc = n_loc, site_sd = site_sd, spat_sd = spat_sd,
phi = phi)
errors$cor_mat  ### correlation matrix among sites in log-scale recruitment error
errors$pacf  ### within site partial-autocorrelation function
error_mat <- errors$ts  ### save the ts for use in the simulation
### initial conditions ### create the data arrays
d1 <- c(0, 2:10)
d2 <- c(paste("Location", 1:n_loc, sep = "_"))
d3 <- 1:n_iter
## set up the abundance array
X <- array(as.numeric(NA), dim = c(10, n_loc, n_iter), dimnames = list(d1, d2, d3))
X[, , 1] <- matrix(c(rep(1e+08, 10), rep(0, each = 40)), ncol = n_loc, byrow = F)
X[, , 2] <- matrix(c(rep(1e+08, 10), rep(0, each = 40)), ncol = n_loc, byrow = F)
## set up the adult biomass array
B <- array(NA, dim = c(n_loc, n_iter, 3), dimnames = list(d2, d3, c("Actual", "Observed",
"Forecast")))
B[, 1, ] <- tons_at_age %*% X[3:10, , 1]/1000
B[, 2, ] <- tons_at_age %*% X[3:10, , 2]/1000
## set up the Forecast adult biomass array
BF <- array(NA, dim = c(n_loc, n_iter, 3), dimnames = list(d2, d3, c("True", "Observed",
"Estimate")))
BF[, 1, ] <- tons_at_age %*% X[3:10, , 1]/1000
BF[, 2, ] <- tons_at_age %*% X[3:10, , 2]/1000
obs_sd <- 0.3
mort_mat[mort_mat_id] <- 1
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = 0,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
mort_mat[mort_mat_id] <- exp(-mort)
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = 0,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
mort_mat[mort_mat_id] <- 1
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
Crand[,,3]
X[, , i]
i
X[,,2]
X[c(1,2),,2]
X[c(1,2),1,2] <- 0
X[c(1,2),,2]
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
SSR_linear <- function(stray_mat, mort_mat, fec_at_age,
eggs, E0, h , R0,
alpha=NULL,beta=NULL,
stage_maturity, errors = 0, X0, n_stages, n_loc) {
### create empty array
X1 <- array(as.numeric(NA), dim = c(n_stages, n_loc))
if (length(dim(mort_mat)) > 2) {
### fill in mortality at age
for (j in 1:5) {
X1[(stage_maturity - 1):n_stages, j] <- mort_mat[, , j] %*% X0[, j]
}
} else {
X1[(stage_maturity - 1):n_stages, ] <- mort_mat %*% X0
}
X1[(stage_maturity - 1):n_stages, ] <- X1[2:n_stages, ] %*% stray_mat
X1[1, ] <- fec_at_age %*% X1[stage_maturity:n_stages, ]
# add recruitment
if (is.null(alpha)){
X1[2, ] <- mapply(BH, E = eggs, E0 = E0, h = h, R0 = R0) * exp(errors)
}
else {
X1[2, ] <- mapply(BH, E = eggs, alpha= alpha,beta=beta) * exp(errors)
}
return(X1)
}
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
X[,,1]
X[,,2]
i=3
Crand[,,2]
SSR_linear_ode <- function(stray, Z, fec_at_age, eggs,
E0, h, R0,
alpha= NULL,beta= NULL,
stage_maturity, errors = 0,
n_loc , n_stages,
inst_h = 0, X0, method = "lsoda") {
S <- n_stages - 1
L <- n_loc
X1 <- array(as.numeric(NA), dim = c(n_stages, n_loc))
col <- rep(1:(S * L), L)
row <- rep(c(1:S), L * L) + rep(0:(L - 1), each = S * L) * S
Zmat <- diag(as.vector(-Z))
Smat <- matrix(simple_triplet_matrix(row, col, rep(t(stray), each = S)), ncol = 45)
diag(Smat) <- rep(diag(stray), each = S) - 1
Fmat <- diag(as.vector(inst_h), ncol = (L * S), nrow = (L * S))
A <- rbind(cbind(Zmat + Smat, matrix(0, nrow = 45, ncol = 45)),
cbind(Fmat, matrix(0, nrow = 45, ncol = 45)))
inits <- matrix(X0)
### generate the survivors and harvest totals ###
fin <- array(t(ode(y = c(X0, rep(0, (S * L))), times = c(0, 1),
func = linear_odes, parms = A, method = method)[2, -1]),
dim = c(S, L, 2))
### split survivors and harvests ###
harvest <- fin[, , 2]
survivors <- fin[, , 1]
survivors[S-1, ] <- survivors[S-1, ] + survivors[S, ]
X1[3:10,] <- survivors[1:8, ]
X1[1, ] <- fec_at_age %*% X1[stage_maturity:n_stages, ]
if (is.null(alpha)){
X1[2, ] <- mapply(BH, E = eggs, E0 = E0, h = h, R0 = R0) * exp(errors)
}
else {
X1[2, ] <- mapply(BH, E = eggs, alpha= alpha,beta=beta) * exp(errors)
}
return(list(X = X1, harvest = harvest))
}
SSR_linear <- function(stray_mat, mort_mat, fec_at_age,
eggs, E0, h , R0,
alpha=NULL,beta=NULL,
stage_maturity, errors = 0, X0, n_stages, n_loc) {
### create empty array
X1 <- array(as.numeric(NA), dim = c(n_stages, n_loc))
if (length(dim(mort_mat)) > 2) {
### fill in mortality at age
for (j in 1:5) {
X1[(stage_maturity - 1):n_stages, j] <- mort_mat[, , j] %*% X0[, j]
}
} else {
X1[(stage_maturity - 1):n_stages, ] <- mort_mat %*% X0
}
X1[(stage_maturity - 1):n_stages, ] <- X1[2:n_stages, ] %*% t(stray_mat)
X1[1, ] <- fec_at_age %*% X1[stage_maturity:n_stages, ]
# add recruitment
if (is.null(alpha)){
X1[2, ] <- mapply(BH, E = eggs, E0 = E0, h = h, R0 = R0) * exp(errors)
}
else {
X1[2, ] <- mapply(BH, E = eggs, alpha= alpha,beta=beta) * exp(errors)
}
return(X1)
}
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
Crand[,,2]
SSR_linear <- function(stray_mat, mort_mat, fec_at_age,
eggs, E0, h , R0,
alpha=NULL,beta=NULL,
stage_maturity, errors = 0, X0, n_stages, n_loc) {
### create empty array
X1 <- array(as.numeric(NA), dim = c(n_stages, n_loc))
if (length(dim(mort_mat)) > 2) {
### fill in mortality at age
for (j in 1:5) {
X1[(stage_maturity - 1):n_stages, j] <- mort_mat[, , j] %*% X0[, j]
}
} else {
X1[(stage_maturity - 1):n_stages, ] <- mort_mat %*% X0
}
X1[(stage_maturity - 1):n_stages, ] <- stray_mat%*%X1[2:n_stages, ]
X1[1, ] <- fec_at_age %*% X1[stage_maturity:n_stages, ]
# add recruitment
if (is.null(alpha)){
X1[2, ] <- mapply(BH, E = eggs, E0 = E0, h = h, R0 = R0) * exp(errors)
}
else {
X1[2, ] <- mapply(BH, E = eggs, alpha= alpha,beta=beta) * exp(errors)
}
return(X1)
}
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
SSR_linear <- function(stray_mat, mort_mat, fec_at_age,
eggs, E0, h , R0,
alpha=NULL,beta=NULL,
stage_maturity, errors = 0, X0, n_stages, n_loc) {
### create empty array
X1 <- array(as.numeric(NA), dim = c(n_stages, n_loc))
if (length(dim(mort_mat)) > 2) {
### fill in mortality at age
for (j in 1:5) {
X1[(stage_maturity - 1):n_stages, j] <- mort_mat[, , j] %*% X0[, j]
}
} else {
X1[(stage_maturity - 1):n_stages, ] <- mort_mat %*% X0
}
X1[(stage_maturity - 1):n_stages, ] <- X1[2:n_stages, ] %*% t(stray_mat)
X1[1, ] <- fec_at_age %*% X1[stage_maturity:n_stages, ]
# add recruitment
if (is.null(alpha)){
X1[2, ] <- mapply(BH, E = eggs, E0 = E0, h = h, R0 = R0) * exp(errors)
}
else {
X1[2, ] <- mapply(BH, E = eggs, alpha= alpha,beta=beta) * exp(errors)
}
return(X1)
}
SSR_linear(alpha=alpha,beta=beta, fec_at_age = fec_at_age,
n_loc = n_loc, n_stages = n_stages,
stage_mat = stage_mat,mort_mat = mort_mat,
eggs = X[1, , i - 2], X0 = X[(stage_mat - 1):n_stages, , i - 1],
stray_mat = Crand[,, i - 1], errors = errors$ts[i - 1, ])
library(Rmetapop)
example(SSR_linear)
library(Rmetapop)
example(SSR_linear)
example(SSR_linear_ode)
library(Rmetapop)
example(SSR_linear_ode)
example(SSR_linear)
example(SSR_linear)
example(SSR_linear)
example(SSR_linear)
example(SSR_linear)
