{
    "contents" : "#' Generate a spatially and temporally correlated time series \n#' @param n_iter number of observations in the multivariate time series.\n#' @param n_loc number of locatons. \n#' @param site_sd univariate standard devation of each time series.\n#' @param spat_sd scale of spatial correlation. \n#' @param phi AR(1) model coefficient.\n#' @param cor_mat user supplied correlation matrix (if unspecified will be generated from the spat_sd parameter).\n#' @description Simulates a multivarate normal, AR(1) time series that can be used for random errors.  Each time point includes vector of correlated deviations, which exhibit either Gaussian spatial correlations OR a specified correlation matrix.   If log = TRUE, the sd is adjusted such that the final expected sd is equal to that specified.\n#' \n#' Step 1: Generate or supply a spatial correlation matrix (cor_mat)\n#' \n#' Step 2: Generate a variance-covariance matrix using site_sd and cor_mat\n#' \n#' Step 3: Create a time series of multivariate normal vectors (each vector is of length n_loc) with n_iter vector observations in the time series. \n#' \n#' Step 4: Run each of the n_log time series through an AR(1) filter with first order correlation phi\n#' \n#' Step 5: Generate observed correlation matrix and vector of first order correlations the time series\n#' @example /inst/examples/spat_temp_ts_examples.R\n#' @seealso \\code{\\link{spat_cor_mat}}\nspat_temp_ts <- function(n_iter, n_loc, site_sd, spat_sd, phi, cor_mat = NULL, log = TRUE) {\n    \n    ### correct site_sd for AR(1) structure\n    site_sd2 <- sqrt(site_sd^2 * (1 - phi^2))\n    \n    ### create spatial covariance matrix if it is not provided\n    if (is.null(cor_mat)) {\n        ### generate the spatial correlation matrix among sites start by generating the\n        ### spatial correlation by distance\n        cor_mat <- spat_cor_mat(n_loc, spat_sd = spat_sd)\n    } else {\n        cor_mat <- cor_mat\n    }\n    \n    ### create the spatial covariance matrix from the correlation matrix ###\n    vcov_mat <- diag(rep(site_sd2, n_loc)) %*% cor_mat %*% diag(rep(site_sd2, n_loc))\n    \n    ### create the empty time series\n    d <- ts(matrix(0, ncol = n_loc, nrow = n_iter))\n    \n    ### create the spatially correlated ts of errors\n    e <- ts(rmvnorm(n_iter, sigma = vcov_mat))\n    ### use the error vector to populate the ts\n    for (i in 2:n_iter) {\n        d[i, ] <- phi * d[i - 1, ] + e[i, ]\n    }\n    \n    ### return spatial correlations and pacf are approximately correct\n    fin_pacf_vec <- apply(d, 2, function(x) pacf(x, plot = F, lag_max = 1)$acf)[1, \n        ]\n    fin_cor_mat <- cor(d)\n    \n    ### provide temporal SD for each location ###\n    fin_sd_vec <- apply(d, 2, sd)\n    if (log == TRUE) {\n        fin_ts <- ts(t(apply(d, 1, \"-\", colMeans(d) + 0.5 * fin_sd_vec^2)))\n    } else {\n        fin_ts <- ts(t(apply(d, 1, \"-\", colMeans(d))))\n    }\n    return(list(pacf = fin_pacf_vec, cor_mat = fin_cor_mat, sd = fin_sd_vec, ts = fin_ts))\n}\n\n#' Generate a spatially correlated matrix\n#' @param n_loc number of locatons. \n#' @param spat_sd scale of spatial correlation for the Gaussian case. \n#' @param spat_sd scale of spatial correlation for the Cauchy case. \n#' @param sumto1 if TRUE makes the columns sum to 1.\n#' @description Generate a spatially correlated matrix where correlations decrease in space via a Gaussian process (with spat_sd) OR a Cauchy process (with spat_scale)\n#' @examples \n#' par(mfrow = c(3,2),mai= c(0.75,0.75,0.75,0.75),mgp = c(1.5,0.5,0.1))\n#' \n#'matplot(spat_cor_mat(n_loc=10, spat_scale = 1),type= \"l\",ylab= \"correlation\",xlab= \"site\",main= \"Cauchy, scale= 1\")\n#'matplot(spat_cor_mat(n_loc=10, spat_sd = 1),type= \"l\",ylab= \"correlation\",xlab= \"site\",main= \"Gaussian, sd= 1\")\n#' matplot(spat_cor_mat(n_loc=10, spat_scale = 2),type= \"l\",ylab= \"correlation\",xlab= \"site\",main= \"Cauchy, scale= 2\")\n#' matplot(spat_cor_mat(n_loc=10, spat_sd = 2),type= \"l\",ylab= \"correlation\",xlab= \"site\",main= \"Gaussian, sd= 2\")\n#' matplot(spat_cor_mat(n_loc=10, spat_scale = 10),type= \"l\",ylab= \"correlation\",xlab= \"site\",main= \"Cauchy, scale= 10\")\n#' matplot(spat_cor_mat(n_loc=10, spat_sd = 10),type= \"l\",ylab= \"correlation\",xlab= \"site\",main= \"Gaussian, sd= 10\")\nspat_cor_mat <- function(n_loc, spat_sd = 1, spat_scale = NULL, sumto1 = FALSE) {\n    if (is.null(spat_scale)) {\n        dn1 <- dnorm(c(1:(2 * n_loc - 1)), mean = n_loc, sd = spat_sd)\n        dn1 <- dn1/dn1[n_loc]\n    } else {\n        dn1 <- dcauchy(c(1:(2 * n_loc - 1)), location = n_loc, scale = spat_scale)\n        dn1 <- dn1/dn1[n_loc]\n    }\n    \n    ### now generate the correlation matrix ###\n    cor_mat <- matrix(dn1[n_loc:(2 * n_loc - 1)])\n    for (i in 1:(n_loc - 1)) {\n        cor_mat <- cbind(cor_mat, dn1[(n_loc:(2 * n_loc - 1)) - (i)])\n    }\n    \n    if (sumto1 == TRUE) {\n        cor_mat <- apply(cor_mat, 2, \"/\", colSums(cor_mat))\n    }\n    return(cor_mat)\n}\n\n#' Generate a series of random stray matrices using a mean stray probability matrix\n#' @param stray_mat a mean stray matrix.\n#' @param n_iter number of observations.\n#' @param scale higher values provide lower variability in random samples.\n#' @description Generate a series of random stray matrices by sampling from the Dirichlet distribution with a mean stray probability matrix and scale parameter\nran_stray_prob <- function(stray_mat,n_iter,scale){\n  Crand <- array(NA, dim = c(dim(stray_mat), n_iter))\n  for (i in 1:n_iter) {\n    Crand[, , i] <- apply(matrix(stray_mat * scale, ncol = ncol(stray_mat)), 2, \n                          rdirichlet, n = 1)\n  }\n  Crand\n}\n\n\n",
    "created" : 1424898896567.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2714788845",
    "id" : "1A1CCF2B",
    "lastKnownWriteTime" : 1424905827,
    "path" : "~/Copy/Post-Doc/Rmetapop/Rmetapop/R/stochasticity.R",
    "project_path" : "Rmetapop/R/stochasticity.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}